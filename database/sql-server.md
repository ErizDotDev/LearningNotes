# üêô SQL Server
---

## Execution Plans

- In order to understand how the database engine works behind the scenes, we need to know the logical operations performed by the query processor.
    
    - This is achieved by investigating the execution plans generated by the query processor.
- An execution plan is a graphical representation of the various steps involved in fetching query results from database tables.
    
    - Once a query is executed, the query processing engine generates multiple execution plans and selects the one that returns the results in the most optimized and performant way.
- There are two types of execution plans:
    
    - **Estimated execution plan**
        - The query processor guesses the operations that will be involved in returning query results.
        - Often generated before the query is executed.
    - **Actual execution plan**
        - Shows the actual operations and steps involved while executing the query.
        - Generated after the query is executed.
- An execution plan is helpful for finding out why the query is slow, which operation takes up a lot of CPU, I/O resources.
    
- In SQL Server Management Studio:
    
    - To show the estimated execution plan, press `Ctrl + L`
    - To show the actual execution plan, press `Ctrl + M`

### Interpreting Execution Plans

- An execution plan is interpreted from **right to left, top to bottom**.
- When you hover over a component, you can view the detailed stats for each operation or component.
- To view what the stats signify, visit this link [Execution Plans in SQL Server (sqlshack.com)](https://www.sqlshack.com/execution-plans-in-sql-server/) and then go to the **Clustered Index Scan** section.

### How queries and execution plans work

- When a query is submitted, the user is telling the SQL Server Engine what it wants but without specifying how to achieve it.

- The SQL Server Engine will perform four internal query processing operations:
    - **Parsing**
        - Once a SQL query is submitted, the query is broken into chunks and is checked by the Relational Engine to make sure it is written correctly (example, no syntax errors)
        - The result of query parsing is a **parsing tree** which is an internal representation of the query that includes steps known as preemptive operations that must be followed to execute the provided query.

    - **Algebrizing**
        - After creating the parsing tree for queries that will manipulate data, the Algebrizer will resolve the names of the different database objects referenced in the given query.
            - It ensures that the database objects are existing in the database and that the user has the right permission to execute the query.
        - The result of an algebrizer is a **query tree**.

    - **Optimizing**
        - The query tree is passed into the optimizer which has the responsibility of creating the most efficient plan with the lowest SQL Server resources consumption. - **Cost-based execution plan**.
            - This is achieved by the optimizer by running through different execution methods (reading all rows, using different indexes, joins) and compromising between different resource consumption scenarios.
        - In situations where complex calculations and aggregations are baked into the query, the optimizer prefers to create a basic plan called **Trivial plan**.
            - This plan is generated instead of finding the most efficient way of handling the query.
- 
    - **Execution**
        - Execution plan is generated based on the query generated by the Query Optimizer from the previous step.
        - When generating the execution plan, it is important to note the database table and indexes statistics.
            - These statistics represent the distribution and uniqueness of the data within the database objects making sure that the optimization level setting is configured as Full.
            - It is important to keep these statistics up to date so that the engine can come up with the most optimized plan.

- The first three processes were performed by the SQL Server Relational Engine.
- The Execution step is performed by the SQL Server Storage Engine.
- If the query submitted does not involve data manipulation, like creating or altering a table, there will be no need to optimize said query.
    - There is only one straight way to perform the query.

- After choosing the most efficient plan for execution, it will be stored in the Plan Cache memory storage.
    - Helpful for retrieving plans and executing them instead of generating new plans every time.
    - Generating execution plan is an extremely expensive process.
    - This is particularly helpful for stored procedures because stored procedures may share common execution plans with other queries that are run in the database despite the different parameters featured in a stored procedure.

### Execution Plans Format

- **Graphical format**
    - Default option
    - Most user friendly format as it provides a quick and easy way to read and analyze the plan.
    - The con for this format is that most details are hidden on tooltips and the user needs to hover different components to check for the details.

- **Text format**
    - Provides the least details from all formats making it hard to read and analyze.
    - Has three different formats:
        - **SHOWPLAN_ALL**
            - Displays the estimated plan of the query that shows complete information about the query execution.
        - **SHOWPLAN_TEXT**
            - Shows very limited information about query execution.
        - **STATISTICS PROFILE**
            - Displays the actual execution plan complete with all relevant information.

- **XML format**
    - Provides complete information about the query execution in an XML format.
    - Comes in two formats:
        - **SHOWPLAN_XML -** For estimated plan
        - **STATISTICS XML -** For actual execution plan

### How to analyze SQL Execution Plan Graphical Components

- A SQL Server login should be granted with the SHOWPLAN permission in order to generate the execution plan.
    - SYSADMIN, DBCREATOR or DB_OWNER roles have automation SHOWPLAN permissions.

- **Query cost**
    - The first value that a user will see in the execution plan.
    - It is a numerical value that is placed in a query which represents the estimated cost of running that query against other queries that were executed on the same file/batch.

- The arrows between the components represent the direction and amount of data that is being transferred from one component to another.
    - The thicker the arrow looks the larger the amount of data that the operation passes.
    - The stats of the data being transferred can be viewed by hovering over the arrow.
        - The stats include the size of each row of data and total size of data passed over in the arrow.

- Below each operator is a number that represents the query cost estimated for that particular operation.
- The information displayed on the popup when the user hovers over the component shows the statistical information of the operator, such as the I/O and CPU costs.
    - These numbers don‚Äôt actually represent the actual amount of resources consumed by this operator but it represents the estimated cost assigned by the Query Optimizer during execution.
    - The key information to look for is the subtree cost which is the percentage of the execution tree the optimizer was able to traverse.
    - Another essential to look at is the Ordered boolean value which represents the state of data in the current operator if it is sorted or not.
        - This can give you a clue if additional processing is needed to sort the data which means extra resources is assigned for that processing.

### Using SQL Execution Plan for Query Performance Tuning

- Check the most expensive operator that has the highest cost relative to the overall query cost.
- The fat arrows followed with thin ones should be looked at as well since it indicates that a large number of records are being flowed and being filtered by the operation to only a few records.
    - Could be a sign for a missing index or data multiplication performance issue.
- Recognize extra operators that degrade the performance of the query.
- Scan operators most of the time indicate that there is a missing index, an index is badly used or the query contains no filtering condition.