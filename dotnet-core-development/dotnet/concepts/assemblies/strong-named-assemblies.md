# Strong named assemblies
---

- Strong name signature in assembly is an identity mechanism to identify assemblies used to verify the integrity of data being passed from the source to the receiver.

- Generated by using a private key that corresponds to the public key distributed with the assembly, and the assembly itself.
    - How is the public key generated? - [[strong-named-assemblies#Creating a private-public key pair|Answer]]
    - How is the private key generated? - [[strong-named-assemblies#Creating a private-public key pair|Answer]]

- Assemblies with same strong name should be identical.

- Why strong name assemblies?
    - Helps prevent malicious parties from tampering assemblies and then re-signing these assemblies with the original signer’s key.
    - For .NET Core and .NET 5+, practically no other benefits.[]

    - For .NET Framework:
        - Strong named assemblies are good reference assemblies
        - Enables side by side testing of different versions of an assembly
        - Allows for cross application use by having the assembly stored in the GAC.
        - Efficiently manage and update assemblies by applying publisher policy.
            - What is a publisher policy and how to implement it?
                - A publisher policy refers to a set of rules that dictate how a runtime should handle versioning and binding of assemblies.
                - No straightforward of achieving this in .NET but with versioning and binding redirects.

- Strong naming assemblies does not guarantee that the assembly is signed by a legitimate entity or person.

### Signing and usage

- An assembly, named Assembly A, is created with a strong name which is generated using one of the following methods:
    - Using Visual Studio
    - Using Strong Name tool to create an encrypted key pair and the Assembly Linker tool to assign the key pair to the assembly.

- The methods above will sign the hash of the file containing the assembly manifest with the developer’s private key which will be stored in the PE file.

- Enter another assembly, Assembly B, which is a consumer of Assembly A. Assembly B has a token that represents Assembly A’s public key.
    - The token is just a part of the public key and is oftentimes used to save space.

- CLR verifies the strong name signature when the assembly is in the GAC.
- When binding by strong name at runtime, CLR compares the key stored in Assembly B manifest to the key used to generate the strong name for Assembly A.
    - If the validations and checks passed, Assembly A’s identity is proven.

### Bypassing signature verification

- Starting .NET Framework 3.5, strong name signatures are not validated when the assembly is loaded into a full-trust application domain.
    - Also referred to as strong bypass feature.
    - Avoids unnecessary overhead of strong name signature verification, making the assembly load times faster.

- This is achieved by changing a registry key, `AllowStrongNameBypass`
    - This will not work if an application is running an account that does not have access to that registry key.

- This can also be achieved per application by adding node `bypassTrustedAppStrongNames` on the configuration/runtime node.

### Creating a private-public key pair

- Uses the Strong Name tool (sn.exe)
- Commands:
    - `sn -k [path/to/snk_file.snk]` - Creates the private-public key pair
    - `sn -p [path/to/snk_file.snk] [path/to/public_key.snk]`
        - Extracts the public key from the private-public key pair.
        - Private key is retained in the private-public key pair file.

### Signing a strong name assembly

- Different ways of achieving this:
    - Through Visual Studio - **Build** > **Strong naming**
    - Through the Assembly Linker (AL.exe) tool
    - Through code by using `AssemblyKeyFileAttribute` and `AssemblyKeyNameAttribute` attributes

### Limitations of strong name

- Keys are constantly being attacked and decrypted.
    - Larger key size is recommended to make it harder to decrypt but it is difficult to change keys and upgrade its size.
        - This process, the new key, breaks all binaries that references the old key.

- Uses a potentially outdated algorithm to sign it, SHA-1. Stronger algorithms are recommended.

### Reference strong named assembly

- Can be done in both compile time and run time.

## Enhanced strong names

- Strong name keys consist of identity key and signature key.
    - Assembly is signed with the signature key and identity key is used to identify the assembly.
    - These two keys are identical.

- In .NET Framework 4.5, the signature key is now generated with a stronger has algorithm.
    - Identity key remains the same.
    - Signature key is also signed with the identity key to create a counter-signature.

- To not break the binaries when upgrading keys to SHA-2, provide the old public key in the `AssemblySignatureKeyAttribute`

### Advantages

- Can take advantage of the SHA-2 algorithms to sign their assemblies.
- Ease of upgrade to SHA-2 as it doesn’t break the binaries like with conventional strong names.