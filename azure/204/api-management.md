# ☮️ API Management
---

- Azure service that helps publish APIs publicly or internally in an organization.

---

## Components

- All of the components of the API Management service is fully managed and hosted by Azure.
- Available in different tiers depending in capacity and features.
### API Gateway

- Accepts API calls and routes them to correct backends.
- Verifies API keys and other credentials provided in a request.
- Caches responses to improve response latency and minimize load on backend service.
- Generates logs, metrics and traces for monitoring, reporting and troubleshooting.

- Transforms requests and responses specified in policy statements.
	- Reserializing the response data returned by the API to make it more readable by the consumer.

- Enforces usage quotas and rate limits.
	- Usage quotas are limits imposed on the amount of API usage allowed per consumer. 
		- Includes number of requests, maximum response size, etc.

### Management Plane

- Administrative interface where the API is setup where you can do the following:
	- Configuration of API management service settings
	- Defining or importing of API schema
	- Set up quotas and transformation policies on the APIs
	- Gain insights from analytics generated by the APIs
	- Manage API users

	- Package APIs into Products ^6fe690
		- Example: You work for a company that provides weather data service to developers and businesses.
			- You create different products for different APIs that you offer.
				- One product for the basic weather data API that gives the basic weather information for the current date, one product for the advanced weather data API that gives advanced information such as historic weather data.
			- Each product will have different transformation policies, metrics, usage quotas etc.
### Developer portal

- Operates similarly to the following:
	- Swagger documentation, a website that contains your API documentation that developers can refer to
	- Stripe developer portal where you can create and manage keys for those who register.

---
### Products

- [[api-management#^6fe690|Basic example]]
- Can be **Open** or **Protected**
	- *Protected* products must be subscribed to first before they can be used.
	- *Open* products are free of use even without a subscription.
- Subscription approval can be configured at a product level and can either require an admin approval or set up for auto approval.
- APIs can be a part of one or more products.

### Groups

- Are like access roles assigned to individual users that control their visibility of the products.
- Have the following static role types:
	- **Administrator** - API creators and maintainers.
	- **Developers**
		- Authenticated developer portal users that use the APIs for their own development projects.
		- Can be a part of one or more groups
		- Can access product visible to the groups where they are members of.
	- **Guests** - Unauthenticated developer portal users which can be granted with read-only access to the APIs.

- Custom roles, groups or external groups can be configured using Microsoft Entra tenants.

---
## Policies

- Allows API publishers to change the behavior of an API through configuration.
- Applied to the API gateway.

- Collection of statements executed sequentially on an API request or response.
	- Statements include: XML to JSON format conversion, rate limiting to reduce the number of incoming calls from a specific developer.

- Applied in different scopes.
	- Can be in a global level, product level, a specific API or an API operation.
	- In a scenario where a global level policy and an API specific policy is applied, both policies will be applied to that specific API.
		- A `base` policy is available where the developers can explicitly specify that higher level policies should be applied in a specific order.

- A policy definition is an XML document containing different sections of inbound and outbound statements:
	- *inbound* - Statements that will apply to the request
	- *backend* - Statements that will be applied before the request enters the backend service
	- *outbound* - Statements that will apply to the response
	- *on-error* - Statements that will apply when an error condition go here
- If an error is encountered on the non-error sections, statements inside these sections will be skipped and the statements inside the on-error section will run instead.
	- Use `context.LastError` to review the error that was encountered, and use `set-body` policy to customize the response based on the error.

- Policy expressions are either:
	- Single line of C# statement enclosed in `@(expression)`; or
	- Multiple lines of C# code enclosed in `@{expression}`
- Policy expressions allow you to modify API behavior without writing custom code or updating your backend code.
- Policies have access to a `context` object.

### Advanced Policies

- **Control flow**
	- Similar to an if-else or switch statement.
	- Characterized by the use of the `when` node with a `condition` attribute.
		- At least one `when` node should exist.

```xml
<choose>
	<when condition="boolean expression">
		<!-- one or more policy statements if the above condition is true. -->
	</when>
	<when condition="boolean expression">
		<!-- one or more policy statements if the above condition is true. -->
	</when>
	<otherwise>
		<!-- one or more policy statements if none of the conditions above is true. -->
		<!-- equivalent of else in an if/else statement. -->
	</otherwise>
</choose>
```

- **Forward request**
	- Forwards the incoming request to the backend service.
	- Backend service URL is defined in the API settings and can be updated using the `set-backend-service` policy.
	- This policy is needed after the transformations and operations are applied to the request so that it will go through the backend service.
		- Not doing so will run the outbound policies immediately.

- **Limit concurrency**
	- Prevents policy statements inside this policy from executing by more than the number of requests specified at the policy at any time.
	- When the number has been exceeded, new requests will immediately return a 429 status code.

- **Log to Event Hub**
	- Sends messages in the specified format to an Event Hub defined by the Logger identity.
	- Used for saving selected requests and response context information for analysis.

- **Mock response**
	- Used to mock APIs.
	- Aborts normal pipeline execution and returns a mocked response to the caller.
	- It tries to generate responses as close to the actual response being returned as possible, utilizing schemas if provided.
		- If no schemas or examples are found, then it will return a response with no content.

- **Retry**
	- Retries policy statements on a given number of attempts until it reaches a max number of attempts or the retry condition becomes false.
	- Similar to [[polly|Polly's retry mechanism]].

- **Return response**
	- Aborts the normal execution and returns either the default or a custom response.
	- Default response is `200 OK` with no body.
	- Custom response is specified via a context variable or policy statement.
	- When both are provided, the custom response will be used.

---

## API Gateway

- [[api-management#API Gateway|What does it do?]]

- It is possible to establish direct line of communication between the back and the front end without the use of API Gateways but it comes with the following drawbacks:
	- Client code becomes more complex and should become resilient enough to handle different failure points.
	- The backend application is required to do the authentication, SSL and rate limiting.
	- Backend will have to utilize protocols that can easily be used by the frontend such as HTTP and WebSocket, limiting the communication protocols one can use.
	- Public endpoints are a potential hub for security attacks.
	- Tight coupling between the client and the backend.
		- Any changes to the URL path of the backend APIs will require a code change.

- Azure offers both managed and self-hosted gateways:
	- **Managed** - Default option where all API traffic flows through Azure regardless of where the backend are hosted.
	- **Self-hosted** - Used for hybrid or multi-cloud setups.

## Securing APIs

### Subscription Keys

- Subscription keys are included in HTTP requests when submitting a request to the APIs.
	- If not, the requests are rejected by the API Gateway.
	- Can be included in the headers with header name `Ocp-Apim-Subscription-Key` or as query parameter with name `subscription-key`

- Subscription keys need subscription and developers who would like to use the API must register for a subscription.
	- Publishers do not need to approve when a user registers for a subscription.
	- Publishers can generate the subscription themselves for the user at any time.

- Subscriptions have different scopes.
	- Can be scoped to all APIs accessible from the gateway. (**All APIs**)
	- Can be scoped to only a single API and all its endpoints (**Single API**)
	- Can be scoped to [[api-management#Products|Products]] which can contain one or more APIs.

- If an API is protected, the subscription key is required in every request.
- Subscription keys generate two keys making it simple for users if the primary key needs to be changed, the secondary key can be used instead.
- Functions like a JWT token.

### Certificates

- Certificates are used to provide TLS (*Transport Layer Security*) authentication between client and API.

- API gateway can be configured to only allow requests that contains certificates with a specific property.
	- Properties that are checked include:
		- Certificate Authority (CA)
		- Thumbprint - A hash calculated from other certificate properties.
		- Subject
		- Expiration Date
	- These properties can be mixed and matched with one another to create a distinct certificate profile for request validation.

- Certificates are signed to ensure that they are not forged in any way.
- Certificates are needed to be verified in the following ways to ensure that the certificate is signed by trusted authorities and not just by anyone:
	- Check the certificate issuer and ensure that the certificate is signed by someone you trust.
		- You can configure your trusted certificates to make the process easier for the succeeding request and certificate validations.
	- Verify that the issuer is the one that signed the certificate.
		- Also known as *self-signed certificates*.

- If the APIs are built with serverless technologies like Azure Functions, you can enable the use of client certificates in the **Consumption tier**.
- A policy needs to be created in order to validate the request with an attached certificate.
	- You can set a condition where you validate the thumbprint from the API to a specific thumbprint value.
	- For scenarios where companies provide multiple certificates with multiple different thumbprints, upload these certificates in Azure portal's **Client certificates** and write code that will validate the incoming certificate with all uploaded certificates.
	- You can also check the certificate issuer and the certificate's subject.

## Commands

- To create an API management instance. ^9bc789

```bash
az apim create -n <api_name> \
	--location <region> \
	--publisher-email <publisher_email> \
	--resource-group <resource_group_name> \
	--publisher-name <publisher_name> \
	--sku-name Consumption
```

